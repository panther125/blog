---
title: 传输层详解
data: 2021-05-29
categories:
- 计算机网络
tags:
- 计算机网络
---
# 概述
* 传输层：只有主机才有的层次
:::info
传输层的功能
:::
1. 传输层提供进程和进程之间的逻辑通信。
2.  复用：应用层所有的应用进程都可以通过传输层再传输到网络层。
    分用：传输层从网络层收到数据后交付指明的应用进程。
3. 传输层对收到的报文进行差错检测。
## 端口号
:::info
服务端
:::
* 熟知端口号(0~ 1023):给TCP/IP最重要的一些应用程序，让所有用户都知道。
* 登记端口号(1024~ 49151):为没有熟知端口号的应用程序使用的。
:::info
客户端
:::
* 客户端口号(49152~ 65535):仅在客户运行时动态选择
**常见端口号**
| 端口号 | 名称 | 描述 | 
|-|-|-|
| 21 | FTP | 用于上传、下载文件 |
| 22 | SSH | 专为远程登录会话和其他网络服务提供安全性的协议 |
| 23 | telnet  | 远程登录 |
| 25 | smtp   | 用于发送邮件 |
| 53 | DNS  | 将域名和IP地址相互映射的一个分布式数据库 |
| 69 | TFTP  | 简单文件传输协议 |
| 80 | HTTP  | 用于网页浏览 |
| 161 | SNMP  | snmp允许远程管理设备 |
## 套接字
* 在网络中采用发送方和接收方的套接字组合来识别端点，套接字**唯一**标识了网络中的一个主机和它上面的一个进程。
* 套接字Socket=(IP+端口号)
# UDP协议
UDP的主要特点：
1. UDP是**无连接**的，减少开销和发送数据之前的时延。
2. UDP使用最大努力交付，即**不保证可靠交付**。
3. UDP是**面向报文**的，适合一次性传输少量数据的网络应用。
4. UDP无拥塞控制，适合很多实时应用。
5. UDP首部开销小，8B,TCP20B。
## UDP的首部格式
![](https://pic.imgdb.cn/item/626e6074239250f7c58604f5.png)
* 源端口号是可有可无的，而目的端口号是必须要有的
* UDP长度：UDP数据报的整个长度
* UDP检验和：检验数据报是否出错，错就会丢弃，如果找不到目的端口号，也会丢弃报文并发送ICMP差错报文
# TCP协议
TCP的主要特点：
1. TCP是面向连接（虚连接）的传输层协议
2. 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的。
3. TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达。
4. TCP提供全双工通信。
发送缓存：准备发送的数据&已发送但尚未收到确认的数据
接收缓存：按序到达但尚未被接受应用程序读取的数据&不按序到达的数据
5. TCP面向字节流
## TCP首部格式
![](https://pic.imgdb.cn/item/626e6085239250f7c5862e16.png)
:::info
控制位
:::
* 紧急位`URG`:
URG=1时，标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。
* 确认位`ACK`:
ACK=1时确认号有效，在连建立后所有传送的报文段都必须把ACK置为1。
* 同步位`SYN`:
SYN=1时，表明是一个连接请求/连接接受报文。
* 终止位`FIN`:
FIN=1时，表明此报文段发送方数据已发完，要求释放连接。
* 窗口：指的是发送本报文段的一方的接收窗口，即现在允许对方发送的数据量。
* 检验和：检验首部+数据，检验时要加上12B伪首部，第四个字段为6。
* 紧急指针：URG=1时才有意义，指出本报文段中紧急数据的字节数。
## TCP的连接
![](https://pic.imgdb.cn/item/626e609d239250f7c5866a57.png)
TCP连接的建立采用**客户服务器方式**，主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫服务器。
![](https://pic.imgdb.cn/item/626e60aa239250f7c5868d95.png)
## SYN洪泛攻击
SYN洪泛攻击发生在[OSI第四层]{.red}，这种方式利用TCP协议的特性，就是三次握手。攻击者发送TCP SYN,`SYN`是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于[挂起状态]{.red}，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送
ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。
## TCP可靠传输
1. 校验：加伪首部
2. 序号：
3. 确认
4. 重传：超时重传
**冗余ACK(冗余确认)**
每当比期望序号大的失序报文段到达时，发送一个冗余ACK,指明下一个期待字节的序号。
发送方已发送1,2,3,4,5报文段
接收方收到1，返回给1的确认（确认号为2的第一个字节）
接收方收到3，仍返回给1的确认（确认号为2的第一个字节）
接收方收到4，仍返回给1的确认（确认号为2的第一个字节)
接收方收到5，仍返回给1的确认（确认号为2的第一个字节）
发送方收到3个对于报文段1的冗余ACK→认为2报文段丢失，重传2号报文段。[快速重传]{.red}
## TCP的流量控制
* 流量控制：让[发送方]{.blue}慢点，要让接收方来得及接收,利用滑动窗口机制实现流量控制
* 在通信过程中，接收方根据自己接收**缓存的大小**，**动态地调整**发送方的发送窗口大小，即接收窗口rwnd(接收方设置确认报文段的窗口字段来将rwnd通知给发送方)，**发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值**
![](https://pic.imgdb.cn/item/626e60ca239250f7c586ebd6.png)
## TCP的拥塞控制
* 若对网络中某一资源的需求**超过了该资源所能提供的可用部分**，网络性能就要变坏，这种情况就叫做[网络拥塞]{.red}
![](https://img-blog.csdnimg.cn/20190731190238241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDMxNDA2,size_16,color_FFFFFF,t_70)
拥塞控制：防止过多的数据注入到网络中。
与流量控制不同的时，**拥塞控制时点对多**而**流量控制时点对点**
:::info
**接收窗口**
`接收方`根据接受缓存设置的值，并告知给发送方，反映接收方容量。
:::
:::info
**拥塞窗口**
`发送方`根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量。
:::
## 算法
TCP的拥塞控制由4个核心算法组成：“慢启动”（Slow Start）、“拥塞避免”（Congestion voidance）、“快速重传 ”（Fast Retransmit）、“快速恢复”（Fast Recovery）
具体的流程图可以参见： http://www.eventhelix.com/RealtimeMantra/Networking/
:::info
慢启动
:::
早期开发的TCP应用在启动一个连接时会向网络中发送大量的数据包，这样很容易导致路由器缓存空间耗尽，网络发生拥塞，使得TCP连接的吞吐量急剧下降。由于TCP源端一开始并不知道网络资源当前的利用状况，因此新建立的TCP连接**不能一开始就发送大量数据，而只能逐步增加每次发送的数据量**，以避免上述现象的发生，这里有一个例子：
假设client要发送5120字节到server，慢启动过程如下：

    1.初始状态，cwnd=1,seq_num=1；client发送第一个segment;
    2.server接收到512字节（一个segment），回应ack_num=513;
    3.client接收ack(513)，cwnd＝1+1=2;现在可以一次发送2个数据段而不必等待ack
    4.server接收到2个segment，回应ack_num=513+512*2=1537
    5.client接收ack(1537)，cwnd=2+1;一次发送3个数据段
    6.server接收到3个segment，回应2个ack，分别为ack_num=1537+1024=2561和ack_num=2561+512=3073
    7.client接收ack(2561)和ack(3073),cwnd=3+2=5；一次可以发送5个数据段，但是只用4个就满足要求了
    8.server接收到4个segment，回应2个ack，分别为4097,5121
    9.已经发送5120字节，任务完成！
[**总结一下**]{.blue}：
当建立新的TCP连接时，拥塞窗口（congestion window，cwnd）初始化为一个数据包大小。源端按cwnd大小发送数据，每收到一个ACK确认，cwnd就增加一个数据包发送量。
:::info
拥塞避免
:::
可以想象，如果按上述慢启动的逻辑继续下去而不加任何控制的话，必然会发生拥塞，引入一个慢启动阈值
ssthresh的概念，
当cwnd < ssthresh的时候，tcp处于慢启动状态，否则，进入拥塞避免阶段。通常，ssthresh初始化为
64 Kbytes。

    当cwnd = 64947 + 512 = 65459，进入拥塞避免阶段，假设此时seq_num = _101024：
    1.client一次发送cwnd，但是先考虑头两个segment
    2.server回应ack_num = 102048
    3.client接收到ack(102048),cwnd = 65459 + [(512 * 512) /65459] = 65459 + 4 = 65463，也就是说，每接到一个ack，cwnd只增加4个字节。
    4.client发送一个segment，并开启ack timer,等待server对这个segment的ack，如果超时，则认为网络已经处于拥塞状态，则重设慢启动阀值ssthresh=当前cwnd/2＝65463/2=32731，并且，立刻把cwnd设为1，很极端的处理！
    5.此时，cwnd < ssthresh，所以，恢复到慢启动状态。
[**总结一下**]{.blue}：
如果当前cwnd达到慢启动阀值，则试探性的发送一个segment，如果server超时未响应，TCP认为网络能力下降，必须降低慢启动阀值，同时，为了避免形势恶化，干脆采取极端措施，把发送窗口降为1.
:::info
快速重传和快速恢复
:::
前面讲过标准的重传，client会等待RTO时间再重传，但有时候，不必等这么久也可以判断需要重传，
例如：
client一次发送8个segment，seq_num起始值为100000，但是由于网络原因，100512丢失，其他的正常，
则server会响应4个ack(100512)(冗余ACK,tcp会把接收的其他segment缓存起来ack_num必须是连续的)
这时候，client接收到四个重复的ack，它完全有理由判断100512丢失，进而重传，而不必傻等RTO时间了。这就是**快速重传**。
**快速恢复**我们通常认为client接收到3个重复的ack后，就会开始快速重传，但是，如果还有更多的重复ack呢，如何处理？这就是快速恢复要做的，事实上，我们可以把快速恢复看作是快速重传的后续处理，它不是一种单独存在的形态。

    假设此时cwnd=70000,client发送4096字节到server,也就是8个segment，起始seq_num = _100000：
    1.client发送seq_num = _100000
    2.seq_num =100512的segment丢失
    3.client发送seq_num = _101024
    4.server接收到两个segment，它意识到100512丢失，先把收到的这两个segment缓存起来
    5.server回应一个ack(100512),表示它还期待这个segment
    6.client发送seq_num = _101536
    7.server接收到一个segment，它判断不是100512，依旧把收到的这个segment缓存起来，并回应ack(100512)
    。
    。
    。
    8.以下同6、7,直到client收到3个ack(100512)，进入快速重发阶段：
    9.重设慢启动阀值ssthresh=当前cwnd/2＝70000/2=35000
    10.client发送seq_num = 100512

    以下，进入快速恢复阶段：
    11.重设cwnd = ssthresh + 3 segments =35000 + 3*512 = 36536，之所以要加3，是因为我们已经接收到3个ack(100512)了，根据前面说的，每接收到一个ack，cwnd加1
    12.client接收到第四个、第五个ack(100512)，cwnd=36536+2*512=37560
    13.server接收到100512,响应ack_num = _104096
    14.此时，cwnd>ssthresh，进入拥塞避免阶段。
